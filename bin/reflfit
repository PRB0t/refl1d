#!/usr/bin/env python

import sys
import os

__file__ = os.path.realpath(__file__)
root = os.path.abspath(os.path.join(os.path.dirname(__file__),'..'))
sys.path.extend((os.path.join(root), 
                 os.path.join(root,"dream")))

import os
import shutil
import subprocess

import numpy
import dream

class DreamModel(dream.MCMCModel):
    """
    DREAM wrapper for refl1d models.
    """
    def __init__(self, problem=None, mapper=None):
        """
        Create a sampling from the multidimensional likelihood function
        represented by the problem set using dream.
        """
        self.problem = problem
        self.bounds = zip(*[p.bounds.limits for p in problem.parameters])
        self.labels = [p.name for p in problem.parameters]
        
        self.mapper = mapper if mapper else lambda p: map(self.log_density,p)

        # Pull things up from 
        self.store = problem.store
        self.dream_opts = problem.dream_opts
        self.name = problem.name
        self.file = problem.file
        self.options = problem.options
        self.setp = problem.setp
        self.title = problem.title

    def nllf(self, x):
        """Negative log likelihood of seeing models given parameters *x*"""
        #print "eval",x; sys.stdout.flush()
        return self.problem.nllf(x)

    def plot(self, x = None, **kw):
        """Display the contents of the model in the current figure"""
        if x is not None: self.problem.setp(x)
        self.problem.plot(**kw)
        
    def show(self, x = None):
        """Display the contents of the model in the current figure"""
        if x is not None: self.problem.setp(x)
        self.problem.show()
        
    def save(self, output, x = None):
        """Display the contents of the model in the current figure"""
        if x is not None: self.problem.setp(x)
        self.problem.save(output)
        
    def map(self, pop):
        return numpy.array(self.mapper(pop))

    output = property(fget=lambda self: os.path.join(self.store,self.name))


class ProfiledModel(DreamModel):
    def map(self, *args, **kw):
        from refl1d.util import profile
        return profile(DreamModel.map, self, *args, **kw)

def draw_samples(model, **kw):
    """
    Draw random samples from the likelihood surface of the models.
    """
    chains = kw.pop('chains',10)
    pop_size = chains*len(model.problem.parameters)
    population = random_population(model.problem, pop_size)
    sampler = dream.Dream(model=model, population=population, **kw)
    
    state = sampler.sample()
    #dream.plot_state(state)
    return state


def random_population(problem, pop_size):
    """
    Generate a random population from the problem parameters.
    """
    # Generate a random population
    population = [p.bounds.random(pop_size) for p in problem.parameters]
    population = numpy.array(population).T

    # Plug in the initial guess
    guess = problem.guess()
    if guess != None:
        population[0] = numpy.asarray(guess)

    # Return the population
    return population[None,:,:]


def load_problem(args):
    #import refl1d.context
    file, options = args[0], args[1:]
    ctx = dict(__file__=file)
    #refl1d.context.math_context(ctx)
    #refl1d.context.refl_context(ctx)
    #refl1d.context.fitting_context(ctx)
    argv = sys.argv
    sys.argv = [file] + options
    execfile(file, ctx) # 2.x
    #exec(compile(open(model_file).read(), model_file, 'exec'), ctx) # 3.0
    sys.argv = argv
    try:
        problem = ctx["problem"]
    except AttributeError:
        raise ValueError(file+" does not define 'problem=FitProblem(models)'")
    problem.file = file
    problem.options = options
    return problem

def preview(model):
    model.show()
    model.plot()
    import pylab; pylab.show()

def make_store(model):
    try: os.mkdir(model.store)
    except: pass
    shutil.copy2(model.file, model.store)
    
    # Record call and model definition
    sys.stdout = open(model.output+".mon","w")
    print "#"," ".join(sys.argv)
    model.show()

def save_best(model, best):
    try:
        model.save(model.output, best)
    except:
        pass
    sys.stdout = open(model.output+".out","w")
    model.show()

    # Plot
    model.plot(fignum=6, figfile=model.output)
    import pylab; pylab.suptitle(":".join((model.store,model.title)))

def run_fit(model):
    make_store(model)
    #mapper = None
    state = draw_samples(model=model, **model.dream_opts)

    # Save results
    state.title = model.name
    state.save(model.output)
    save_best(model, state.best()[0])
    state.show(figfile=model.output)

def start_worker(model):
    #sys.stdout = open("dream-%d.log"%os.getpid(),"w")
    #print "worker is starting"; sys.stdout.flush()
    from amqp_map.config import SERVICE_HOST
    from amqp_map.core import connect, start_worker as serve
    server = connect(SERVICE_HOST)
    os.system("echo 'serving' > /home/pkienzle/map.%d"%(os.getpid()))
    #print "worker is serving"; sys.stdout.flush()
    serve(server, "dream", model.log_density)
    #print "worker ended"; sys.stdout.flush()

def start_mapper(modelargs):
    from amqp_map.config import SERVICE_HOST
    from amqp_map.core import connect, Mapper

    server = connect(SERVICE_HOST)
    mapper = Mapper(server, "dream")
    pipes = []
    for _ in range(8):
        cmd = [sys.argv[0], "-worker"] + modelargs
        #print "starting",sys.argv[0],"in",os.getcwd(),"with",cmd
        pipe = subprocess.Popen(cmd, universal_newlines=True,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        pipes.append(pipe)
    for pipe in pipes:
        if pipe.poll() > 0:
            raise RuntimeError("subprocess returned %d\nout: %s\nerr: %s"
                               % (pipe.returncode, pipe.stdout, pipe.stderr))
        #os.system(" ".join(cmd+["&"]))
    import atexit
    def exit_fun():
        for p in pipes: p.terminate()
    atexit.register(exit_fun)
    
    return mapper

def stop_mapper(mapper):
    for pipe in mapper.pipes:
        pipe.terminate()


class ParseOpts:
    MINARGS = 0
    FLAGS = set()
    VALUES = set()
    USAGE = ""    
    def __init__(self, args):
        self._parse(args)

    def _parse(self, args):
        if len(sys.argv) == 1:
            print >>sys.stderr,self.USAGE
            sys.exit(1)

        flagargs = [v for v in sys.argv[1:] if v.startswith('-') and not '=' in v]
        flags = set(v[1:] for v in flagargs)
        unknown = flags - self.FLAGS
        if any(unknown):
            raise ValueError("Unknown flags -%s"%", -".join(unknown))
        for f in self.FLAGS:
            setattr(self, f, (f in flags))

        positionargs = [v for v in sys.argv[1:] if not v.startswith('-')]
        if len(positionargs) < self.MINARGS:
            raise ValueError("Not enough arguments")
        self.args = positionargs

        valueargs = [v for v in sys.argv[1:] if v.startswith('-') and '=' in v]
        for f in valueargs:
            idx = f.find('=')
            name = f[1:idx]
            value = f[idx+1:]
            if name not in self.VALUES:
                raise ValueError("Unknown option -%s"%name)
            setattr(self, name, value)

class FitOpts(ParseOpts):
    MINARGS = 1
    FLAGS = set(("preview","profile","worker","batch"))
    VALUES = set(("plot","store"))
    USAGE = """\
Usage: fit [-option] modelfile [modelargs]

where options includes

    -preview : display model but do not fit
    -profile : run with profiling
    -batch  : batch mode; no plot
    -plot=q4|fresnel|log|linear : how to plot reflectivity

For convenience options can be anywhere on the command line.

Model arguments may not start with '-'.
"""

    _plot = 'log'
    def _set_plot(self, value):
        if value not in set(('log', 'linear', 'fresnel', 'q4')):
            raise ValueError("unknown plot type %s; use log, linear, fresnel or q4"%value)
        self._plot = value
    plot = property(fget=lambda self: self._plot, fset=_set_plot)
    store = None

def main():
    opts = FitOpts(sys.argv)
    problem = load_problem(opts.args)
    if opts.profile:
        model = ProfiledModel(problem=problem)
    else:
        model = DreamModel(problem=problem)

    # Which format to view the plots
    from refl1d import Probe
    Probe.view = opts.plot

    # Where to store the results
    if opts.store != None: model.store = opts.store

    #print "flags", flags
    if opts.preview:
        preview(model)
    elif opts.worker:
        # This is the worker process.
        #os.system("echo '%s worker' > /home/pkienzle/map.%d"%('starting',os.getpid()))
        start_worker(model)
    else:
        #print "starting master"
        # This is the master process.
        if opts.profile:
            model.dream_opts = dict(chains=10,draws=1000,burn=0)
            model.title = "profiling"
        else:
            model.mapper = start_mapper(opts.args)
        run_fit(model)
        if not opts.batch:
            import pylab; pylab.show()

if __name__ == "__main__": main()
